(window.webpackJsonp=window.webpackJsonp||[]).push([[40],{470:function(v,t,_){"use strict";_.r(t);var e=_(54),o=Object(e.a)({},(function(){var v=this,t=v.$createElement,_=v._self._c||t;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h2",{attrs:{id:"线程共享"}},[v._v("线程共享")]),v._v(" "),_("h3",{attrs:{id:"堆"}},[v._v("堆")]),v._v(" "),_("ul",[_("li",[v._v("JVM启动时被创建，并且其实际内存空间可以是不连续的")]),v._v(" "),_("li",[v._v("用于对象实例存储，自然是GC垃圾回收的重点区域，所以可能在大内存的使用和回收上成为性能瓶颈，逃逸分析栈上分配应运而生")]),v._v(" "),_("li",[v._v("YoungGen\n"),_("ul",[_("li",[v._v("Eden")]),v._v(" "),_("li",[v._v("From Survivor")]),v._v(" "),_("li",[v._v("To Survivor")])])]),v._v(" "),_("li",[v._v("OldGen")])]),v._v(" "),_("h3",{attrs:{id:"方法区-元数据区"}},[v._v("方法区/元数据区")]),v._v(" "),_("blockquote",[_("p",[v._v("存储了每一个类的结构信息，如：运行时常量，字段和方法数据，构造函数和普通方法的字节码内容等，该区域在逻辑上是独立的，物理上仍属于堆的一部分。")])]),v._v(" "),_("h2",{attrs:{id:"线程私有"}},[v._v("线程私有")]),v._v(" "),_("h3",{attrs:{id:"pc-寄存器"}},[v._v("PC 寄存器")]),v._v(" "),_("blockquote",[_("p",[v._v("JVM内存区中唯一一个没有明确规定需要抛出OMM异常的运行时内存区。")])]),v._v(" "),_("blockquote",[_("p",[v._v("CPU不断地做任务切换，PC寄存器用于记录当前线程正在执行的当前字节码指令地址。")])]),v._v(" "),_("h3",{attrs:{id:"栈"}},[v._v("栈")]),v._v(" "),_("blockquote",[_("p",[v._v("栈用于存储栈帧，栈帧存储的是局部变量表，操作数栈，以及方法出口等，局部变量表存储原始数据类型、对象引用以及returnAddress类型。")])]),v._v(" "),_("h3",{attrs:{id:"本地方法栈"}},[v._v("本地方法栈")]),v._v(" "),_("blockquote",[_("p",[v._v("用于支持native方法的执行。")])]),v._v(" "),_("h3",{attrs:{id:"内存泄漏-溢出"}},[v._v("内存泄漏/溢出")]),v._v(" "),_("blockquote",[_("p",[v._v("场景：打算释放一个链表所引用的所有空间时，却错误地只释放了链表的第一个元素，而剩下的元素尽管已经不再被引用，但是他们却离开了整个程序的检控范围，其所占用的内存空间将永远无法释放...尽管内存泄漏并不会立刻引起程序奔溃，但是一旦发生内存泄漏，程序中的可用内存就会被逐步蚕食，直至内存耗尽，导致程序奔溃。")])]),v._v(" "),_("h3",{attrs:{id:"内存分配"}},[v._v("内存分配")]),v._v(" "),_("blockquote",[_("p",[v._v("当使用new创建一个Java对象时，JVM首先会检查new指令的参数能否在常量池中定位到一个类的符号引用，然后检查与该符号引用相对应的类是否已经成功经历了加载、连接和初始化等步骤，完成装载后就完全可以确定出创建对象实例时所需要的内存空间大小了，然后JVM对其进行内存分配")])]),v._v(" "),_("blockquote",[_("p",[v._v("由于对象实例的创建在JVM中非常频繁，因堆和方法区是线程共享的，所以在并发环境下从堆区划分内存空间是非线程安全的，所以务必需要保证数据操作的原子性。基于线程安全的考虑，如果一个类在分配内存之前已经成功完成类装载步骤之后，JVM会优先选择在TLAB(Thread Local Allocation,本地线程分配缓冲区)中为对象实例分配内存空间，TLAB在堆区是一块线程私有区域，包含在Eden空间内，除了可以避免非线程安全外，还可以提升内存分配的吞吐量，此谓快速分配策略。")])]),v._v(" "),_("blockquote",[_("p",[v._v("默认TLAB占Eden的1%，可通过-XX:TLABWasteTargetPercent设置TLAB占Eden的百分比大小，一旦对象在TLAB内存分配失败后，JVM就会通过使用加锁机制确保数据操作的原子性从Eden空间分配内存，若Eden亦分配失败，JVM会执行Minor GC直至Eden有足够空间分配内存，当然若大对象，则直接在OldGen分配内存。")])])])}),[],!1,null,null,null);t.default=o.exports}}]);